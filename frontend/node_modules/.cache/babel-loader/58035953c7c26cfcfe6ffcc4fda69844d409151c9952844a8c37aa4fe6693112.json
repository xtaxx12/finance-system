{"ast":null,"code":"function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport * as React from 'react';\nimport { Children, PureComponent, useCallback, useContext, useEffect } from 'react';\nimport { clsx } from 'clsx';\nimport { scalePoint } from 'victory-vendor/d3-scale';\nimport range from 'es-toolkit/compat/range';\nimport { Layer } from '../container/Layer';\nimport { Text } from '../component/Text';\nimport { getValueByDataKey } from '../util/ChartUtils';\nimport { isNumber, isNotNil } from '../util/DataUtils';\nimport { generatePrefixStyle } from '../util/CssPrefixUtils';\nimport { useChartData, useDataIndex } from '../context/chartDataContext';\nimport { BrushUpdateDispatchContext } from '../context/brushUpdateContext';\nimport { useAppDispatch, useAppSelector } from '../state/hooks';\nimport { setDataStartEndIndexes } from '../state/chartDataSlice';\nimport { setBrushSettings } from '../state/brushSlice';\nimport { PanoramaContextProvider } from '../context/PanoramaContext';\nimport { selectBrushDimensions } from '../state/selectors/brushSelectors';\nimport { useBrushChartSynchronisation } from '../synchronisation/useChartSynchronisation';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { svgPropertiesNoEvents } from '../util/svgPropertiesNoEvents';\n\n// Why is this tickFormatter different from the other TickFormatters? This one allows to return numbers too for some reason.\n\nfunction DefaultTraveller(props) {\n  var {\n    x,\n    y,\n    width,\n    height,\n    stroke\n  } = props;\n  var lineY = Math.floor(y + height / 2) - 1;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"rect\", {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    fill: stroke,\n    stroke: \"none\"\n  }), /*#__PURE__*/React.createElement(\"line\", {\n    x1: x + 1,\n    y1: lineY,\n    x2: x + width - 1,\n    y2: lineY,\n    fill: \"none\",\n    stroke: \"#fff\"\n  }), /*#__PURE__*/React.createElement(\"line\", {\n    x1: x + 1,\n    y1: lineY + 2,\n    x2: x + width - 1,\n    y2: lineY + 2,\n    fill: \"none\",\n    stroke: \"#fff\"\n  }));\n}\nfunction Traveller(props) {\n  var {\n    travellerProps,\n    travellerType\n  } = props;\n  if (/*#__PURE__*/React.isValidElement(travellerType)) {\n    // @ts-expect-error element cloning disagrees with the types (and it should)\n    return /*#__PURE__*/React.cloneElement(travellerType, travellerProps);\n  }\n  if (typeof travellerType === 'function') {\n    return travellerType(travellerProps);\n  }\n  return /*#__PURE__*/React.createElement(DefaultTraveller, travellerProps);\n}\nfunction TravellerLayer(_ref) {\n  var _data$startIndex, _data$endIndex;\n  var {\n    otherProps,\n    travellerX,\n    id,\n    onMouseEnter,\n    onMouseLeave,\n    onMouseDown,\n    onTouchStart,\n    onTravellerMoveKeyboard,\n    onFocus,\n    onBlur\n  } = _ref;\n  var {\n    y,\n    x: xFromProps,\n    travellerWidth,\n    height,\n    traveller,\n    ariaLabel,\n    data,\n    startIndex,\n    endIndex\n  } = otherProps;\n  var x = Math.max(travellerX, xFromProps);\n  var travellerProps = _objectSpread(_objectSpread({}, svgPropertiesNoEvents(otherProps)), {}, {\n    x,\n    y,\n    width: travellerWidth,\n    height\n  });\n  var ariaLabelBrush = ariaLabel || \"Min value: \".concat((_data$startIndex = data[startIndex]) === null || _data$startIndex === void 0 ? void 0 : _data$startIndex.name, \", Max value: \").concat((_data$endIndex = data[endIndex]) === null || _data$endIndex === void 0 ? void 0 : _data$endIndex.name);\n  return /*#__PURE__*/React.createElement(Layer, {\n    tabIndex: 0,\n    role: \"slider\",\n    \"aria-label\": ariaLabelBrush,\n    \"aria-valuenow\": travellerX,\n    className: \"recharts-brush-traveller\",\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave,\n    onMouseDown: onMouseDown,\n    onTouchStart: onTouchStart,\n    onKeyDown: e => {\n      if (!['ArrowLeft', 'ArrowRight'].includes(e.key)) {\n        return;\n      }\n      e.preventDefault();\n      e.stopPropagation();\n      onTravellerMoveKeyboard(e.key === 'ArrowRight' ? 1 : -1, id);\n    },\n    onFocus: onFocus,\n    onBlur: onBlur,\n    style: {\n      cursor: 'col-resize'\n    }\n  }, /*#__PURE__*/React.createElement(Traveller, {\n    travellerType: traveller,\n    travellerProps: travellerProps\n  }));\n}\n/*\n * This one cannot be a React Component because React is not happy with it returning only string | number.\n * React wants a full React.JSX.Element but that is not compatible with Text component.\n */\nfunction getTextOfTick(props) {\n  var {\n    index,\n    data,\n    tickFormatter,\n    dataKey\n  } = props;\n  // @ts-expect-error getValueByDataKey does not validate the output type\n  var text = getValueByDataKey(data[index], dataKey, index);\n  return typeof tickFormatter === 'function' ? tickFormatter(text, index) : text;\n}\nfunction getIndexInRange(valueRange, x) {\n  var len = valueRange.length;\n  var start = 0;\n  var end = len - 1;\n  while (end - start > 1) {\n    var middle = Math.floor((start + end) / 2);\n    if (valueRange[middle] > x) {\n      end = middle;\n    } else {\n      start = middle;\n    }\n  }\n  return x >= valueRange[end] ? end : start;\n}\nfunction getIndex(_ref2) {\n  var {\n    startX,\n    endX,\n    scaleValues,\n    gap,\n    data\n  } = _ref2;\n  var lastIndex = data.length - 1;\n  var min = Math.min(startX, endX);\n  var max = Math.max(startX, endX);\n  var minIndex = getIndexInRange(scaleValues, min);\n  var maxIndex = getIndexInRange(scaleValues, max);\n  return {\n    startIndex: minIndex - minIndex % gap,\n    endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap\n  };\n}\nfunction Background(_ref3) {\n  var {\n    x,\n    y,\n    width,\n    height,\n    fill,\n    stroke\n  } = _ref3;\n  return /*#__PURE__*/React.createElement(\"rect\", {\n    stroke: stroke,\n    fill: fill,\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  });\n}\nfunction BrushText(_ref4) {\n  var {\n    startIndex,\n    endIndex,\n    y,\n    height,\n    travellerWidth,\n    stroke,\n    tickFormatter,\n    dataKey,\n    data,\n    startX,\n    endX\n  } = _ref4;\n  var offset = 5;\n  var attrs = {\n    pointerEvents: 'none',\n    fill: stroke\n  };\n  return /*#__PURE__*/React.createElement(Layer, {\n    className: \"recharts-brush-texts\"\n  }, /*#__PURE__*/React.createElement(Text, _extends({\n    textAnchor: \"end\",\n    verticalAnchor: \"middle\",\n    x: Math.min(startX, endX) - offset,\n    y: y + height / 2\n  }, attrs), getTextOfTick({\n    index: startIndex,\n    tickFormatter,\n    dataKey,\n    data\n  })), /*#__PURE__*/React.createElement(Text, _extends({\n    textAnchor: \"start\",\n    verticalAnchor: \"middle\",\n    x: Math.max(startX, endX) + travellerWidth + offset,\n    y: y + height / 2\n  }, attrs), getTextOfTick({\n    index: endIndex,\n    tickFormatter,\n    dataKey,\n    data\n  })));\n}\nfunction Slide(_ref5) {\n  var {\n    y,\n    height,\n    stroke,\n    travellerWidth,\n    startX,\n    endX,\n    onMouseEnter,\n    onMouseLeave,\n    onMouseDown,\n    onTouchStart\n  } = _ref5;\n  var x = Math.min(startX, endX) + travellerWidth;\n  var width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);\n  return /*#__PURE__*/React.createElement(\"rect\", {\n    className: \"recharts-brush-slide\",\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave,\n    onMouseDown: onMouseDown,\n    onTouchStart: onTouchStart,\n    style: {\n      cursor: 'move'\n    },\n    stroke: \"none\",\n    fill: stroke,\n    fillOpacity: 0.2,\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  });\n}\nfunction Panorama(_ref6) {\n  var {\n    x,\n    y,\n    width,\n    height,\n    data,\n    children,\n    padding\n  } = _ref6;\n  var isPanoramic = React.Children.count(children) === 1;\n  if (!isPanoramic) {\n    return null;\n  }\n  var chartElement = Children.only(children);\n  if (!chartElement) {\n    return null;\n  }\n  return /*#__PURE__*/React.cloneElement(chartElement, {\n    x,\n    y,\n    width,\n    height,\n    margin: padding,\n    compact: true,\n    data\n  });\n}\nvar createScale = _ref7 => {\n  var {\n    data,\n    startIndex,\n    endIndex,\n    x,\n    width,\n    travellerWidth\n  } = _ref7;\n  if (!data || !data.length) {\n    return {};\n  }\n  var len = data.length;\n  var scale = scalePoint().domain(range(0, len)).range([x, x + width - travellerWidth]);\n  var scaleValues = scale.domain().map(entry => scale(entry)).filter(isNotNil);\n  return {\n    isTextActive: false,\n    isSlideMoving: false,\n    isTravellerMoving: false,\n    isTravellerFocused: false,\n    startX: scale(startIndex),\n    endX: scale(endIndex),\n    scale,\n    scaleValues\n  };\n};\nvar isTouch = e => e.changedTouches && !!e.changedTouches.length;\nclass BrushWithState extends PureComponent {\n  constructor(props) {\n    super(props);\n    _defineProperty(this, \"handleDrag\", e => {\n      if (this.leaveTimer) {\n        clearTimeout(this.leaveTimer);\n        this.leaveTimer = null;\n      }\n      if (this.state.isTravellerMoving) {\n        this.handleTravellerMove(e);\n      } else if (this.state.isSlideMoving) {\n        this.handleSlideDrag(e);\n      }\n    });\n    _defineProperty(this, \"handleTouchMove\", e => {\n      if (e.changedTouches != null && e.changedTouches.length > 0) {\n        this.handleDrag(e.changedTouches[0]);\n      }\n    });\n    _defineProperty(this, \"handleDragEnd\", () => {\n      this.setState({\n        isTravellerMoving: false,\n        isSlideMoving: false\n      }, () => {\n        var {\n          endIndex,\n          onDragEnd,\n          startIndex\n        } = this.props;\n        onDragEnd === null || onDragEnd === void 0 || onDragEnd({\n          endIndex,\n          startIndex\n        });\n      });\n      this.detachDragEndListener();\n    });\n    _defineProperty(this, \"handleLeaveWrapper\", () => {\n      if (this.state.isTravellerMoving || this.state.isSlideMoving) {\n        this.leaveTimer = window.setTimeout(this.handleDragEnd, this.props.leaveTimeOut);\n      }\n    });\n    _defineProperty(this, \"handleEnterSlideOrTraveller\", () => {\n      this.setState({\n        isTextActive: true\n      });\n    });\n    _defineProperty(this, \"handleLeaveSlideOrTraveller\", () => {\n      this.setState({\n        isTextActive: false\n      });\n    });\n    _defineProperty(this, \"handleSlideDragStart\", e => {\n      var event = isTouch(e) ? e.changedTouches[0] : e;\n      this.setState({\n        isTravellerMoving: false,\n        isSlideMoving: true,\n        slideMoveStartX: event.pageX\n      });\n      this.attachDragEndListener();\n    });\n    _defineProperty(this, \"handleTravellerMoveKeyboard\", (direction, id) => {\n      var {\n        data,\n        gap,\n        startIndex,\n        endIndex\n      } = this.props;\n      // scaleValues are a list of coordinates. For example: [65, 250, 435, 620, 805, 990].\n      var {\n        scaleValues,\n        startX,\n        endX\n      } = this.state;\n      if (scaleValues == null) {\n        return;\n      }\n\n      // unless we search for the closest scaleValue to the current coordinate\n      // we need to move travelers via index when using the keyboard\n      var currentIndex = -1;\n      if (id === 'startX') {\n        currentIndex = startIndex;\n      } else if (id === 'endX') {\n        currentIndex = endIndex;\n      }\n      if (currentIndex < 0 || currentIndex >= data.length) {\n        return;\n      }\n      var newIndex = currentIndex + direction;\n      if (newIndex === -1 || newIndex >= scaleValues.length) {\n        return;\n      }\n      var newScaleValue = scaleValues[newIndex];\n\n      // Prevent travellers from being on top of each other or overlapping\n      if (id === 'startX' && newScaleValue >= endX || id === 'endX' && newScaleValue <= startX) {\n        return;\n      }\n      this.setState(\n      // @ts-expect-error not sure why typescript is not happy with this, partial update is fine in React\n      {\n        [id]: newScaleValue\n      }, () => {\n        this.props.onChange(getIndex({\n          startX: this.state.startX,\n          endX: this.state.endX,\n          data,\n          gap,\n          scaleValues\n        }));\n      });\n    });\n    this.travellerDragStartHandlers = {\n      startX: this.handleTravellerDragStart.bind(this, 'startX'),\n      endX: this.handleTravellerDragStart.bind(this, 'endX')\n    };\n    this.state = {\n      brushMoveStartX: 0,\n      movingTravellerId: undefined,\n      endX: 0,\n      startX: 0,\n      slideMoveStartX: 0\n    };\n  }\n  static getDerivedStateFromProps(nextProps, prevState) {\n    var {\n      data,\n      width,\n      x,\n      travellerWidth,\n      startIndex,\n      endIndex,\n      startIndexControlledFromProps,\n      endIndexControlledFromProps\n    } = nextProps;\n    if (data !== prevState.prevData) {\n      return _objectSpread({\n        prevData: data,\n        prevTravellerWidth: travellerWidth,\n        prevX: x,\n        prevWidth: width\n      }, data && data.length ? createScale({\n        data,\n        width,\n        x,\n        travellerWidth,\n        startIndex,\n        endIndex\n      }) : {\n        scale: undefined,\n        scaleValues: undefined\n      });\n    }\n    var prevScale = prevState.scale;\n    if (prevScale && (width !== prevState.prevWidth || x !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {\n      prevScale.range([x, x + width - travellerWidth]);\n      var scaleValues = prevScale.domain().map(entry => prevScale(entry)).filter(value => value != null);\n      return {\n        prevData: data,\n        prevTravellerWidth: travellerWidth,\n        prevX: x,\n        prevWidth: width,\n        startX: prevScale(nextProps.startIndex),\n        endX: prevScale(nextProps.endIndex),\n        scaleValues\n      };\n    }\n    if (prevState.scale && !prevState.isSlideMoving && !prevState.isTravellerMoving && !prevState.isTravellerFocused && !prevState.isTextActive) {\n      /*\n       * If the startIndex or endIndex are controlled from the outside,\n       * we need to keep the startX and end up to date.\n       * Also we do not want to do that while user is interacting in the brush,\n       * because this will trigger re-render and interrupt the drag&drop.\n       */\n      if (startIndexControlledFromProps != null && prevState.prevStartIndexControlledFromProps !== startIndexControlledFromProps) {\n        return {\n          startX: prevState.scale(startIndexControlledFromProps),\n          prevStartIndexControlledFromProps: startIndexControlledFromProps\n        };\n      }\n      if (endIndexControlledFromProps != null && prevState.prevEndIndexControlledFromProps !== endIndexControlledFromProps) {\n        return {\n          endX: prevState.scale(endIndexControlledFromProps),\n          prevEndIndexControlledFromProps: endIndexControlledFromProps\n        };\n      }\n    }\n    return null;\n  }\n  componentWillUnmount() {\n    if (this.leaveTimer) {\n      clearTimeout(this.leaveTimer);\n      this.leaveTimer = null;\n    }\n    this.detachDragEndListener();\n  }\n  attachDragEndListener() {\n    window.addEventListener('mouseup', this.handleDragEnd, true);\n    window.addEventListener('touchend', this.handleDragEnd, true);\n    window.addEventListener('mousemove', this.handleDrag, true);\n  }\n  detachDragEndListener() {\n    window.removeEventListener('mouseup', this.handleDragEnd, true);\n    window.removeEventListener('touchend', this.handleDragEnd, true);\n    window.removeEventListener('mousemove', this.handleDrag, true);\n  }\n  handleSlideDrag(e) {\n    var {\n      slideMoveStartX,\n      startX,\n      endX,\n      scaleValues\n    } = this.state;\n    if (scaleValues == null) {\n      return;\n    }\n    var {\n      x,\n      width,\n      travellerWidth,\n      startIndex,\n      endIndex,\n      onChange,\n      data,\n      gap\n    } = this.props;\n    var delta = e.pageX - slideMoveStartX;\n    if (delta > 0) {\n      delta = Math.min(delta, x + width - travellerWidth - endX, x + width - travellerWidth - startX);\n    } else if (delta < 0) {\n      delta = Math.max(delta, x - startX, x - endX);\n    }\n    var newIndex = getIndex({\n      startX: startX + delta,\n      endX: endX + delta,\n      data,\n      gap,\n      scaleValues\n    });\n    if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) {\n      onChange(newIndex);\n    }\n    this.setState({\n      startX: startX + delta,\n      endX: endX + delta,\n      slideMoveStartX: e.pageX\n    });\n  }\n  handleTravellerDragStart(id, e) {\n    var event = isTouch(e) ? e.changedTouches[0] : e;\n    this.setState({\n      isSlideMoving: false,\n      isTravellerMoving: true,\n      movingTravellerId: id,\n      brushMoveStartX: event.pageX\n    });\n    this.attachDragEndListener();\n  }\n  handleTravellerMove(e) {\n    var {\n      brushMoveStartX,\n      movingTravellerId,\n      endX,\n      startX,\n      scaleValues\n    } = this.state;\n    if (movingTravellerId == null || scaleValues == null) {\n      return;\n    }\n    var prevValue = this.state[movingTravellerId];\n    var {\n      x,\n      width,\n      travellerWidth,\n      onChange,\n      gap,\n      data\n    } = this.props;\n    var params = {\n      startX: this.state.startX,\n      endX: this.state.endX,\n      data,\n      gap,\n      scaleValues\n    };\n    var delta = e.pageX - brushMoveStartX;\n    if (delta > 0) {\n      delta = Math.min(delta, x + width - travellerWidth - prevValue);\n    } else if (delta < 0) {\n      delta = Math.max(delta, x - prevValue);\n    }\n    params[movingTravellerId] = prevValue + delta;\n    var newIndex = getIndex(params);\n    var {\n      startIndex,\n      endIndex\n    } = newIndex;\n    var isFullGap = () => {\n      var lastIndex = data.length - 1;\n      if (movingTravellerId === 'startX' && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === 'endX' && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) {\n        return true;\n      }\n      return false;\n    };\n    this.setState(\n    // @ts-expect-error not sure why typescript is not happy with this, partial update is fine in React\n    {\n      [movingTravellerId]: prevValue + delta,\n      brushMoveStartX: e.pageX\n    }, () => {\n      if (onChange) {\n        if (isFullGap()) {\n          onChange(newIndex);\n        }\n      }\n    });\n  }\n  render() {\n    var {\n      data,\n      className,\n      children,\n      x,\n      y,\n      dy,\n      width,\n      height,\n      alwaysShowText,\n      fill,\n      stroke,\n      startIndex,\n      endIndex,\n      travellerWidth,\n      tickFormatter,\n      dataKey,\n      padding\n    } = this.props;\n    var {\n      startX,\n      endX,\n      isTextActive,\n      isSlideMoving,\n      isTravellerMoving,\n      isTravellerFocused\n    } = this.state;\n    if (!data || !data.length || !isNumber(x) || !isNumber(y) || !isNumber(width) || !isNumber(height) || width <= 0 || height <= 0) {\n      return null;\n    }\n    var layerClass = clsx('recharts-brush', className);\n    var style = generatePrefixStyle('userSelect', 'none');\n    var calculatedY = y + (dy !== null && dy !== void 0 ? dy : 0);\n    return /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass,\n      onMouseLeave: this.handleLeaveWrapper,\n      onTouchMove: this.handleTouchMove,\n      style: style\n    }, /*#__PURE__*/React.createElement(Background, {\n      x: x,\n      y: calculatedY,\n      width: width,\n      height: height,\n      fill: fill,\n      stroke: stroke\n    }), /*#__PURE__*/React.createElement(PanoramaContextProvider, null, /*#__PURE__*/React.createElement(Panorama, {\n      x: x,\n      y: calculatedY,\n      width: width,\n      height: height,\n      data: data,\n      padding: padding\n    }, children)), /*#__PURE__*/React.createElement(Slide, {\n      y: calculatedY,\n      height: height,\n      stroke: stroke,\n      travellerWidth: travellerWidth,\n      startX: startX,\n      endX: endX,\n      onMouseEnter: this.handleEnterSlideOrTraveller,\n      onMouseLeave: this.handleLeaveSlideOrTraveller,\n      onMouseDown: this.handleSlideDragStart,\n      onTouchStart: this.handleSlideDragStart\n    }), /*#__PURE__*/React.createElement(TravellerLayer, {\n      travellerX: startX,\n      id: \"startX\",\n      otherProps: _objectSpread(_objectSpread({}, this.props), {}, {\n        y: calculatedY\n      }),\n      onMouseEnter: this.handleEnterSlideOrTraveller,\n      onMouseLeave: this.handleLeaveSlideOrTraveller,\n      onMouseDown: this.travellerDragStartHandlers.startX,\n      onTouchStart: this.travellerDragStartHandlers.startX,\n      onTravellerMoveKeyboard: this.handleTravellerMoveKeyboard,\n      onFocus: () => {\n        this.setState({\n          isTravellerFocused: true\n        });\n      },\n      onBlur: () => {\n        this.setState({\n          isTravellerFocused: false\n        });\n      }\n    }), /*#__PURE__*/React.createElement(TravellerLayer, {\n      travellerX: endX,\n      id: \"endX\",\n      otherProps: _objectSpread(_objectSpread({}, this.props), {}, {\n        y: calculatedY\n      }),\n      onMouseEnter: this.handleEnterSlideOrTraveller,\n      onMouseLeave: this.handleLeaveSlideOrTraveller,\n      onMouseDown: this.travellerDragStartHandlers.endX,\n      onTouchStart: this.travellerDragStartHandlers.endX,\n      onTravellerMoveKeyboard: this.handleTravellerMoveKeyboard,\n      onFocus: () => {\n        this.setState({\n          isTravellerFocused: true\n        });\n      },\n      onBlur: () => {\n        this.setState({\n          isTravellerFocused: false\n        });\n      }\n    }), (isTextActive || isSlideMoving || isTravellerMoving || isTravellerFocused || alwaysShowText) && /*#__PURE__*/React.createElement(BrushText, {\n      startIndex: startIndex,\n      endIndex: endIndex,\n      y: calculatedY,\n      height: height,\n      travellerWidth: travellerWidth,\n      stroke: stroke,\n      tickFormatter: tickFormatter,\n      dataKey: dataKey,\n      data: data,\n      startX: startX,\n      endX: endX\n    }));\n  }\n}\nfunction BrushInternal(props) {\n  var dispatch = useAppDispatch();\n  var chartData = useChartData();\n  var dataIndexes = useDataIndex();\n  var onChangeFromContext = useContext(BrushUpdateDispatchContext);\n  var onChangeFromProps = props.onChange;\n  var {\n    startIndex: startIndexFromProps,\n    endIndex: endIndexFromProps\n  } = props;\n  useEffect(() => {\n    // start and end index can be controlled from props, and we need them to stay up-to-date in the Redux state too\n    dispatch(setDataStartEndIndexes({\n      startIndex: startIndexFromProps,\n      endIndex: endIndexFromProps\n    }));\n  }, [dispatch, endIndexFromProps, startIndexFromProps]);\n  useBrushChartSynchronisation();\n  var onChange = useCallback(nextState => {\n    if (dataIndexes == null) {\n      return;\n    }\n    var {\n      startIndex,\n      endIndex\n    } = dataIndexes;\n    if (nextState.startIndex !== startIndex || nextState.endIndex !== endIndex) {\n      onChangeFromContext === null || onChangeFromContext === void 0 || onChangeFromContext(nextState);\n      onChangeFromProps === null || onChangeFromProps === void 0 || onChangeFromProps(nextState);\n      dispatch(setDataStartEndIndexes(nextState));\n    }\n  }, [onChangeFromProps, onChangeFromContext, dispatch, dataIndexes]);\n  var brushDimensions = useAppSelector(selectBrushDimensions);\n  if (brushDimensions == null || dataIndexes == null || chartData == null || !chartData.length) {\n    return null;\n  }\n  var {\n    startIndex,\n    endIndex\n  } = dataIndexes;\n  var {\n    x,\n    y,\n    width\n  } = brushDimensions;\n  var contextProperties = {\n    data: chartData,\n    x,\n    y,\n    width,\n    startIndex,\n    endIndex,\n    onChange\n  };\n  return /*#__PURE__*/React.createElement(BrushWithState, _extends({}, props, contextProperties, {\n    startIndexControlledFromProps: startIndexFromProps !== null && startIndexFromProps !== void 0 ? startIndexFromProps : undefined,\n    endIndexControlledFromProps: endIndexFromProps !== null && endIndexFromProps !== void 0 ? endIndexFromProps : undefined\n  }));\n}\nfunction BrushSettingsDispatcher(props) {\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    dispatch(setBrushSettings(props));\n    return () => {\n      dispatch(setBrushSettings(null));\n    };\n  }, [dispatch, props]);\n  return null;\n}\nexport var defaultBrushProps = {\n  height: 40,\n  travellerWidth: 5,\n  gap: 1,\n  fill: '#fff',\n  stroke: '#666',\n  padding: {\n    top: 1,\n    right: 1,\n    bottom: 1,\n    left: 1\n  },\n  leaveTimeOut: 1000,\n  alwaysShowText: false\n};\nexport function Brush(outsideProps) {\n  var props = resolveDefaultProps(outsideProps, defaultBrushProps);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(BrushSettingsDispatcher, {\n    height: props.height,\n    x: props.x,\n    y: props.y,\n    width: props.width,\n    padding: props.padding\n  }), /*#__PURE__*/React.createElement(BrushInternal, props));\n}\nBrush.displayName = 'Brush';","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}