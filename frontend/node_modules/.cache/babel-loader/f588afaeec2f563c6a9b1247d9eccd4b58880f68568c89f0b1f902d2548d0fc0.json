{"ast":null,"code":"var _excluded = [\"shape\", \"activeShape\", \"cornerRadius\", \"id\"],\n  _excluded2 = [\"onMouseEnter\", \"onClick\", \"onMouseLeave\"],\n  _excluded3 = [\"value\", \"background\"];\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nimport * as React from 'react';\nimport { PureComponent, useCallback, useRef, useState } from 'react';\nimport { clsx } from 'clsx';\nimport { parseCornerRadius, RadialBarSector } from '../util/RadialBarUtils';\nimport { Layer } from '../container/Layer';\nimport { findAllByType } from '../util/ReactUtils';\nimport { LabelListFromLabelProp, PolarLabelListContextProvider } from '../component/LabelList';\nimport { Cell } from '../component/Cell';\nimport { interpolate, mathSign } from '../util/DataUtils';\nimport { getCateCoordinateOfBar, getNormalizedStackId, getTooltipNameProp, getValueByDataKey, truncateByDomain } from '../util/ChartUtils';\nimport { adaptEventsOfChild } from '../util/types';\nimport { useMouseClickItemDispatch, useMouseEnterItemDispatch, useMouseLeaveItemDispatch } from '../context/tooltipContext';\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\nimport { selectRadialBarLegendPayload, selectRadialBarSectors } from '../state/selectors/radialBarSelectors';\nimport { useAppSelector } from '../state/hooks';\nimport { selectActiveTooltipIndex } from '../state/selectors/tooltipSelectors';\nimport { SetPolarLegendPayload } from '../state/SetLegendPayload';\nimport { useAnimationId } from '../util/useAnimationId';\nimport { RegisterGraphicalItemId } from '../context/RegisterGraphicalItemId';\nimport { SetPolarGraphicalItem } from '../state/SetGraphicalItem';\nimport { svgPropertiesNoEvents, svgPropertiesNoEventsFromUnknown } from '../util/svgPropertiesNoEvents';\nimport { JavascriptAnimate } from '../animation/JavascriptAnimate';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { ZIndexLayer } from '../zIndex/ZIndexLayer';\nimport { DefaultZIndexes } from '../zIndex/DefaultZIndexes';\nimport { getZIndexFromUnknown } from '../zIndex/getZIndexFromUnknown';\nvar STABLE_EMPTY_ARRAY = [];\nfunction RadialBarLabelListProvider(_ref) {\n  var {\n    showLabels,\n    sectors,\n    children\n  } = _ref;\n  var labelListEntries = sectors.map(sector => ({\n    value: sector.value,\n    payload: sector.payload,\n    parentViewBox: undefined,\n    clockWise: false,\n    viewBox: {\n      cx: sector.cx,\n      cy: sector.cy,\n      innerRadius: sector.innerRadius,\n      outerRadius: sector.outerRadius,\n      startAngle: sector.startAngle,\n      endAngle: sector.endAngle,\n      clockWise: false\n    },\n    fill: sector.fill\n  }));\n  return /*#__PURE__*/React.createElement(PolarLabelListContextProvider, {\n    value: showLabels ? labelListEntries : undefined\n  }, children);\n}\nfunction RadialBarSectors(_ref2) {\n  var {\n    sectors,\n    allOtherRadialBarProps,\n    showLabels\n  } = _ref2;\n  var {\n      shape,\n      activeShape,\n      cornerRadius,\n      id\n    } = allOtherRadialBarProps,\n    others = _objectWithoutProperties(allOtherRadialBarProps, _excluded);\n  var baseProps = svgPropertiesNoEvents(others);\n  var activeIndex = useAppSelector(selectActiveTooltipIndex);\n  var {\n      onMouseEnter: onMouseEnterFromProps,\n      onClick: onItemClickFromProps,\n      onMouseLeave: onMouseLeaveFromProps\n    } = allOtherRadialBarProps,\n    restOfAllOtherProps = _objectWithoutProperties(allOtherRadialBarProps, _excluded2);\n  var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherRadialBarProps.dataKey, id);\n  var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);\n  var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherRadialBarProps.dataKey, id);\n  if (sectors == null) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(RadialBarLabelListProvider, {\n    showLabels: showLabels,\n    sectors: sectors\n  }, sectors.map((entry, i) => {\n    var isActive = activeShape && activeIndex === String(i);\n    // @ts-expect-error the types need a bit of attention\n    var onMouseEnter = onMouseEnterFromContext(entry, i);\n    // @ts-expect-error the types need a bit of attention\n    var onMouseLeave = onMouseLeaveFromContext(entry, i);\n    // @ts-expect-error the types need a bit of attention\n    var onClick = onClickFromContext(entry, i);\n    var radialBarSectorProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, baseProps), {}, {\n      cornerRadius: parseCornerRadius(cornerRadius)\n    }, entry), adaptEventsOfChild(restOfAllOtherProps, entry, i)), {}, {\n      onMouseEnter,\n      onMouseLeave,\n      onClick,\n      className: \"recharts-radial-bar-sector \".concat(entry.className),\n      forceCornerRadius: others.forceCornerRadius,\n      cornerIsExternal: others.cornerIsExternal,\n      isActive,\n      option: isActive ? activeShape : shape\n    });\n    if (isActive) {\n      return /*#__PURE__*/React.createElement(ZIndexLayer, {\n        zIndex: DefaultZIndexes.activeBar,\n        key: \"sector-\".concat(entry.cx, \"-\").concat(entry.cy, \"-\").concat(entry.innerRadius, \"-\").concat(entry.outerRadius, \"-\").concat(entry.startAngle, \"-\").concat(entry.endAngle, \"-\").concat(i)\n      }, /*#__PURE__*/React.createElement(RadialBarSector, radialBarSectorProps));\n    }\n    return /*#__PURE__*/React.createElement(RadialBarSector, _extends({\n      key: \"sector-\".concat(entry.cx, \"-\").concat(entry.cy, \"-\").concat(entry.innerRadius, \"-\").concat(entry.outerRadius, \"-\").concat(entry.startAngle, \"-\").concat(entry.endAngle, \"-\").concat(i)\n    }, radialBarSectorProps));\n  }), /*#__PURE__*/React.createElement(LabelListFromLabelProp, {\n    label: allOtherRadialBarProps.label\n  }), allOtherRadialBarProps.children);\n}\nfunction SectorsWithAnimation(_ref3) {\n  var {\n    props,\n    previousSectorsRef\n  } = _ref3;\n  var {\n    data,\n    isAnimationActive,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    onAnimationEnd,\n    onAnimationStart\n  } = props;\n  var animationId = useAnimationId(props, 'recharts-radialbar-');\n  var prevData = previousSectorsRef.current;\n  var [isAnimating, setIsAnimating] = useState(false);\n  var handleAnimationEnd = useCallback(() => {\n    if (typeof onAnimationEnd === 'function') {\n      onAnimationEnd();\n    }\n    setIsAnimating(false);\n  }, [onAnimationEnd]);\n  var handleAnimationStart = useCallback(() => {\n    if (typeof onAnimationStart === 'function') {\n      onAnimationStart();\n    }\n    setIsAnimating(true);\n  }, [onAnimationStart]);\n  return /*#__PURE__*/React.createElement(JavascriptAnimate, {\n    animationId: animationId,\n    begin: animationBegin,\n    duration: animationDuration,\n    isActive: isAnimationActive,\n    easing: animationEasing,\n    onAnimationStart: handleAnimationStart,\n    onAnimationEnd: handleAnimationEnd,\n    key: animationId\n  }, t => {\n    var stepData = t === 1 ? data : (data !== null && data !== void 0 ? data : STABLE_EMPTY_ARRAY).map((entry, index) => {\n      var prev = prevData && prevData[index];\n      if (prev) {\n        return _objectSpread(_objectSpread({}, entry), {}, {\n          startAngle: interpolate(prev.startAngle, entry.startAngle, t),\n          endAngle: interpolate(prev.endAngle, entry.endAngle, t)\n        });\n      }\n      var {\n        endAngle,\n        startAngle\n      } = entry;\n      return _objectSpread(_objectSpread({}, entry), {}, {\n        endAngle: interpolate(startAngle, endAngle, t)\n      });\n    });\n    if (t > 0) {\n      // eslint-disable-next-line no-param-reassign\n      previousSectorsRef.current = stepData !== null && stepData !== void 0 ? stepData : null;\n    }\n    return /*#__PURE__*/React.createElement(Layer, null, /*#__PURE__*/React.createElement(RadialBarSectors, {\n      sectors: stepData !== null && stepData !== void 0 ? stepData : STABLE_EMPTY_ARRAY,\n      allOtherRadialBarProps: props,\n      showLabels: !isAnimating\n    }));\n  });\n}\nfunction RenderSectors(props) {\n  var previousSectorsRef = useRef(null);\n  return /*#__PURE__*/React.createElement(SectorsWithAnimation, {\n    props: props,\n    previousSectorsRef: previousSectorsRef\n  });\n}\nfunction SetRadialBarPayloadLegend(props) {\n  var legendPayload = useAppSelector(state => selectRadialBarLegendPayload(state, props.legendType));\n  return /*#__PURE__*/React.createElement(SetPolarLegendPayload, {\n    legendPayload: legendPayload !== null && legendPayload !== void 0 ? legendPayload : []\n  });\n}\nvar SetRadialBarTooltipEntrySettings = /*#__PURE__*/React.memo(_ref4 => {\n  var {\n    dataKey,\n    data,\n    stroke,\n    strokeWidth,\n    name,\n    hide,\n    fill,\n    tooltipType,\n    id\n  } = _ref4;\n  var tooltipEntrySettings = {\n    dataDefinedOnItem: data,\n    positions: undefined,\n    settings: {\n      graphicalItemId: id,\n      stroke,\n      strokeWidth,\n      fill,\n      nameKey: undefined,\n      // RadialBar does not have nameKey, why?\n      dataKey,\n      name: getTooltipNameProp(name, dataKey),\n      hide,\n      type: tooltipType,\n      color: fill,\n      unit: '' // Why does RadialBar not support unit?\n    }\n  };\n  return /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\n    tooltipEntrySettings: tooltipEntrySettings\n  });\n});\nclass RadialBarWithState extends PureComponent {\n  renderBackground(sectors) {\n    if (sectors == null) {\n      return null;\n    }\n    var {\n      cornerRadius\n    } = this.props;\n    var backgroundProps = svgPropertiesNoEventsFromUnknown(this.props.background);\n    return /*#__PURE__*/React.createElement(ZIndexLayer, {\n      zIndex: getZIndexFromUnknown(this.props.background, DefaultZIndexes.barBackground)\n    }, sectors.map((entry, i) => {\n      var {\n          value,\n          background\n        } = entry,\n        rest = _objectWithoutProperties(entry, _excluded3);\n      if (!background) {\n        return null;\n      }\n      var props = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n        cornerRadius: parseCornerRadius(cornerRadius)\n      }, rest), {}, {\n        // @ts-expect-error backgroundProps is contributing unknown props\n        fill: '#eee'\n      }, background), backgroundProps), adaptEventsOfChild(this.props, entry, i)), {}, {\n        index: i,\n        className: clsx('recharts-radial-bar-background-sector', String(backgroundProps === null || backgroundProps === void 0 ? void 0 : backgroundProps.className)),\n        option: background,\n        isActive: false\n      });\n      return /*#__PURE__*/React.createElement(RadialBarSector, _extends({\n        key: \"background-\".concat(rest.cx, \"-\").concat(rest.cy, \"-\").concat(rest.innerRadius, \"-\").concat(rest.outerRadius, \"-\").concat(rest.startAngle, \"-\").concat(rest.endAngle, \"-\").concat(i)\n      }, props));\n    }));\n  }\n  render() {\n    var {\n      hide,\n      data,\n      className,\n      background\n    } = this.props;\n    if (hide) {\n      return null;\n    }\n    var layerClass = clsx('recharts-area', className);\n    return /*#__PURE__*/React.createElement(ZIndexLayer, {\n      zIndex: this.props.zIndex\n    }, /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass\n    }, background && /*#__PURE__*/React.createElement(Layer, {\n      className: \"recharts-radial-bar-background\"\n    }, this.renderBackground(data)), /*#__PURE__*/React.createElement(Layer, {\n      className: \"recharts-radial-bar-sectors\"\n    }, /*#__PURE__*/React.createElement(RenderSectors, this.props))));\n  }\n}\nfunction RadialBarImpl(props) {\n  var _useAppSelector;\n  var cells = findAllByType(props.children, Cell);\n  var radialBarSettings = {\n    data: undefined,\n    hide: false,\n    id: props.id,\n    dataKey: props.dataKey,\n    minPointSize: props.minPointSize,\n    stackId: getNormalizedStackId(props.stackId),\n    maxBarSize: props.maxBarSize,\n    barSize: props.barSize,\n    type: 'radialBar',\n    angleAxisId: props.angleAxisId,\n    radiusAxisId: props.radiusAxisId\n  };\n  var data = (_useAppSelector = useAppSelector(state => selectRadialBarSectors(state, props.radiusAxisId, props.angleAxisId, radialBarSettings, cells))) !== null && _useAppSelector !== void 0 ? _useAppSelector : STABLE_EMPTY_ARRAY;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SetRadialBarTooltipEntrySettings, {\n    dataKey: props.dataKey,\n    data: data,\n    stroke: props.stroke,\n    strokeWidth: props.strokeWidth,\n    name: props.name,\n    hide: props.hide,\n    fill: props.fill,\n    tooltipType: props.tooltipType,\n    id: props.id\n  }), /*#__PURE__*/React.createElement(RadialBarWithState, _extends({}, props, {\n    data: data\n  })));\n}\nexport var defaultRadialBarProps = {\n  angleAxisId: 0,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  background: false,\n  cornerIsExternal: false,\n  cornerRadius: 0,\n  data: [],\n  forceCornerRadius: false,\n  hide: false,\n  isAnimationActive: 'auto',\n  label: false,\n  legendType: 'rect',\n  minPointSize: 0,\n  radiusAxisId: 0,\n  zIndex: DefaultZIndexes.bar\n};\nexport function computeRadialBarDataItems(_ref5) {\n  var {\n    displayedData,\n    stackedData,\n    dataStartIndex,\n    stackedDomain,\n    dataKey,\n    baseValue,\n    layout,\n    radiusAxis,\n    radiusAxisTicks,\n    bandSize,\n    pos,\n    angleAxis,\n    minPointSize,\n    cx,\n    cy,\n    angleAxisTicks,\n    cells,\n    startAngle: rootStartAngle,\n    endAngle: rootEndAngle\n  } = _ref5;\n  if (angleAxisTicks == null || radiusAxisTicks == null) {\n    return STABLE_EMPTY_ARRAY;\n  }\n  return (displayedData !== null && displayedData !== void 0 ? displayedData : []).map((entry, index) => {\n    var value, innerRadius, outerRadius, startAngle, endAngle, backgroundSector;\n    if (stackedData) {\n      // @ts-expect-error truncateByDomain expects only numerical domain, but it can received categorical domain too\n      value = truncateByDomain(stackedData[dataStartIndex + index], stackedDomain);\n    } else {\n      value = getValueByDataKey(entry, dataKey);\n      if (!Array.isArray(value)) {\n        value = [baseValue, value];\n      }\n    }\n    if (layout === 'radial') {\n      innerRadius = getCateCoordinateOfBar({\n        axis: radiusAxis,\n        ticks: radiusAxisTicks,\n        bandSize,\n        offset: pos.offset,\n        entry,\n        index\n      });\n      endAngle = angleAxis.scale(value[1]);\n      startAngle = angleAxis.scale(value[0]);\n      outerRadius = (innerRadius !== null && innerRadius !== void 0 ? innerRadius : 0) + pos.size;\n      var deltaAngle = endAngle - startAngle;\n      if (Math.abs(minPointSize) > 0 && Math.abs(deltaAngle) < Math.abs(minPointSize)) {\n        var delta = mathSign(deltaAngle || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaAngle));\n        endAngle += delta;\n      }\n      backgroundSector = {\n        background: {\n          cx,\n          cy,\n          innerRadius,\n          outerRadius,\n          startAngle: rootStartAngle,\n          endAngle: rootEndAngle\n        }\n      };\n    } else {\n      innerRadius = radiusAxis.scale(value[0]);\n      outerRadius = radiusAxis.scale(value[1]);\n      startAngle = getCateCoordinateOfBar({\n        axis: angleAxis,\n        ticks: angleAxisTicks,\n        bandSize,\n        offset: pos.offset,\n        entry,\n        index\n      });\n      endAngle = (startAngle !== null && startAngle !== void 0 ? startAngle : 0) + pos.size;\n      var deltaRadius = outerRadius - innerRadius;\n      if (Math.abs(minPointSize) > 0 && Math.abs(deltaRadius) < Math.abs(minPointSize)) {\n        var _delta = mathSign(deltaRadius || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaRadius));\n        outerRadius += _delta;\n      }\n    }\n    return _objectSpread(_objectSpread(_objectSpread({}, entry), backgroundSector), {}, {\n      payload: entry,\n      value: stackedData ? value : value[1],\n      cx,\n      cy,\n      innerRadius,\n      outerRadius,\n      startAngle,\n      endAngle\n    }, cells && cells[index] && cells[index].props);\n  });\n}\nexport function RadialBar(outsideProps) {\n  var props = resolveDefaultProps(outsideProps, defaultRadialBarProps);\n  return /*#__PURE__*/React.createElement(RegisterGraphicalItemId, {\n    id: props.id,\n    type: \"radialBar\"\n  }, id => {\n    var _props$hide, _props$angleAxisId, _props$radiusAxisId;\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SetPolarGraphicalItem, {\n      type: \"radialBar\",\n      id: id,\n      data: undefined // why does RadialBar not allow data defined on the item?\n      ,\n\n      dataKey: props.dataKey,\n      hide: (_props$hide = props.hide) !== null && _props$hide !== void 0 ? _props$hide : defaultRadialBarProps.hide,\n      angleAxisId: (_props$angleAxisId = props.angleAxisId) !== null && _props$angleAxisId !== void 0 ? _props$angleAxisId : defaultRadialBarProps.angleAxisId,\n      radiusAxisId: (_props$radiusAxisId = props.radiusAxisId) !== null && _props$radiusAxisId !== void 0 ? _props$radiusAxisId : defaultRadialBarProps.radiusAxisId,\n      stackId: getNormalizedStackId(props.stackId),\n      barSize: props.barSize,\n      minPointSize: props.minPointSize,\n      maxBarSize: props.maxBarSize\n    }), /*#__PURE__*/React.createElement(SetRadialBarPayloadLegend, props), /*#__PURE__*/React.createElement(RadialBarImpl, _extends({}, props, {\n      id: id\n    })));\n  });\n}\nRadialBar.displayName = 'RadialBar';","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}